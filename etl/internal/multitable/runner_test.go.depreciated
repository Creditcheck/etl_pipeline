package multitable

import (
	"strings"
	"testing"
)

func TestParseCSV_ExtractsImportsAndDistinctCountries(t *testing.T) {
	csvData := `PČV,Stát,Datum dovozu
8429529,Spolková republika Německo,
8429533,Velká Británie a Severní Irsko,
8429535,Spolková republika Německo,
8429556,Spolková republika Německo,
`

	opt := CSVOptions{
		Comma:          ",",
		ExpectedFields: 3,
		HasHeader:      true,
		HeaderMap: map[string]string{
			"Datum dovozu": "datum_dovozu",
			"PČV":          "pcv",
			"Stát":         "stat",
		},
		TrimSpace: true,
	}

	imports, distinct, err := parseCSV(strings.NewReader(csvData), opt)
	if err != nil {
		t.Fatalf("parseCSV: %v", err)
	}
	if len(imports) != 4 {
		t.Fatalf("expected 4 imports, got %d", len(imports))
	}
	if _, ok := distinct["Spolková republika Německo"]; !ok {
		t.Fatalf("expected Germany in distinct")
	}
	if _, ok := distinct["Velká Británie a Severní Irsko"]; !ok {
		t.Fatalf("expected UK in distinct")
	}
}

func TestBuildImportsCopyRows_ResolvesCountryIDs(t *testing.T) {
	imports := []ImportRow{
		{PCV: 1, Country: "A", ImportDate: nil},
		{PCV: 2, Country: "B", ImportDate: nil},
	}
	ids := map[string]int64{"A": 10, "B": 20}

	rows, err := buildImportsCopyRows(imports, ids)
	if err != nil {
		t.Fatalf("buildImportsCopyRows: %v", err)
	}
	if len(rows) != 2 {
		t.Fatalf("expected 2 rows, got %d", len(rows))
	}
	if rows[0][0].(int64) != 1 || rows[0][1].(int64) != 10 || rows[0][2] != nil {
		t.Fatalf("unexpected first row: %#v", rows[0])
	}
	if rows[1][0].(int64) != 2 || rows[1][1].(int64) != 20 {
		t.Fatalf("unexpected second row: %#v", rows[1])
	}
}
